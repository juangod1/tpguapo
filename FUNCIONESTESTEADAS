int menu(game_data_type *game_data)
{
	int menu_state=1, opcion=0;
	char file[]={};
	while(menu_state)
	{
		CLEAR_GRAPHICS;

		if (opcion==-1) 
			printf("\nError al leer parametros.\n");

		printf("\n1. Juego de dos jugadores\n2. Juego contra computadora\n3. Recuperar un juego grabado\n4. Terminar\n\nElija la opcion correspondiente: ");		
		scanf("%d", &opcion);
		if(getchar()!='\n')
		{
			opcion=-1;
			BORRA_BUFFER;
		}
		switch(opcion){
			case 1 ... 2:
				(*game_data).size_y = getint("Ingrese la cantidad de filas (Entre 5 y 30): ");
				(*game_data).size_x = getint("Ingrese la cantidad de columnas (Entre 5 y 30): ");
				if (((*game_data).size_y>30)||((*game_data).size_y<5)||((*game_data).size_x<5)||((*game_data).size_x>30))
					opcion = -1;
				else
					menu_state = 0;	
				break;	
			case 3:
				printf("Ingrese el nombre del archivo: ");
				scanf("%s",file);
				if (getchar()!='\n') /* || (NO ENCUENTRA EL ARCHIVO) no se como pija lo vamos a hacer */ 
				{
					printf("Error al cargar (El archivo esta corrupto o no existe)\n");
					opcion = -1;
				}
				else 
					menu_state = 0;	
				break;
			case 4:
				CLEAR_GRAPHICS;
				exit(0);
				break;
			default:
				opcion = -1;
				break;
			}
	}
	return (*game_data).mode = opcion;
}

void modify_Adjacent_Blocks(game_data_type *game_data)
{
    int i=(*game_data).to_x-1, j=(*game_data).to_y-1, auxj;
    i=((i<0)?(0):(i));
    auxj=((j<0)?(0):(j));
    for(i=i; i<=(*game_data).to_x+1; i++)
    {
        for(j=auxj; j<=(*game_data).to_y+1; j++)
        {
            if((*game_data).board[j][i]!=0 && j<=(*game_data).size_y && i<=(*game_data).size_x)
                (*game_data).board[j][i]=(*game_data).board[(*game_data).to_y][(*game_data).to_x];
        }
    }
}

void modify_Board(game_data_type *game_data, int move_type)
{
	char character = ((((*game_data).upnext)%2)?'A':'Z');
	(*game_data).board[(*game_data).to_y][(*game_data).to_x] = character;
	if (move_type==2) (*game_data).board[(*game_data).from_y][(*game_data).from_x] = 0;
	modify_Adjacent_Blocks(game_data);
}

void display_Board(game_data_type *game_data)
{
	int i,j,k=0;
	CLEAR_GRAPHICS;
	putchar('\n');
	for ( i=0 ; i<(*game_data).size_y ; i++ )
	{
		if (i<10) printf("%d ",k++);
		else printf("%d",k++);
		putchar('|');
		for ( j=0 ; j<(*game_data).size_x ; j++ )
		{
			if ((*game_data).board[i][j] == 0)
				printf("%c |", (*game_data).board[i][j]);
			else 
				printf("%c|", (*game_data).board[i][j]);
		}
		putchar('\n');
	}
	printf("   ");
	for (i=0;i!=k;i++)
		{
			if (i<10) printf("%d ",i);
			else printf("%d",i);
		}
	putchar('\n');
}
int initial_Turn(game_data_type *game_data)
{
	int turn;
	if ( (*game_data).mode != 3) /* NEWGAME */
	{
		turn = rand() % 2;
	}

	else /* CONTINUE */
	{

	}

	return turn;
}

int valid_Space(game_data_type *game_data, int i, int j)
{
	int validity=0;
	if(((*game_data).board[i][j] == 0) && (i<(*game_data).size_y) && (j<(*game_data).size_x) && (i>-1) && (j>-1))
		validity=1;
	return validity;
}

int check_Move(game_data_type *game_data)
{
	int move_type; /* 0 si es invalida, 1 si es mitosis, 2 si es salto */
	float distance, hip = ((*game_data).from_x-(*game_data).to_x)*((*game_data).from_x-(*game_data).to_x)+((*game_data).from_y-(*game_data).to_y)*((*game_data).from_y-(*game_data).to_y);

	distance = sqrt(hip);
	
	if ( (*game_data).board[(*game_data).from_y][(*game_data).from_x] == (((*game_data).upnext%2)?'A':'Z') )
	{
		if ((distance==1)||((distance<=sqrt(2)+0.05) && (distance>= sqrt(2)-0.05)))  		/* Estoy chequeando que la distancia*/ 
			move_type = 1;																	/*    sea la de un salto correcto   */
		else if ((distance==2)||((distance<=sqrt(8)+0.05) && (distance>= sqrt(8)-0.05))) 
			move_type = 2;
		else 
			move_type = 0;

		if ( !valid_Space(game_data, (*game_data).to_y, (*game_data).to_x))
			move_type = 0;
	}
	else
		move_type = 0;
	return move_type;
}

int main()
{
int i;

game_data_type game_data;

game_data.size_y=5;
game_data.size_x=5;
game_data.from_x=2;
game_data.from_y=2;
game_data.to_x=2;
game_data.to_y=0;
game_data.upnext=2;
game_data.mode=0;
char *aux = &game_data.board;
for(i=0; i<900; i++)
	aux[i]=0;

}


